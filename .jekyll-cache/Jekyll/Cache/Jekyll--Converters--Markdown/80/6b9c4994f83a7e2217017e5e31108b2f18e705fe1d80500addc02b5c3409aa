I"˜<h5 id="ç”µè¯çš„å‘¼å…¥æ¥é€šæŒ‚æ–­ç›‘å¬å®ç°æ–¹æ¡ˆ">ç”µè¯çš„å‘¼å…¥ã€æ¥é€šã€æŒ‚æ–­ç›‘å¬å®ç°æ–¹æ¡ˆ</h5>

<blockquote>
  <p>å¤§é™†åœ°åŒºä¸å…è®¸ä½¿ç”¨CallKit,é‚®ä»¶ç­‰æ²Ÿé€šæ— æœ,ç”µè¯çš„ç›‘å¬å¿…é¡»æ›´æ¢ä¸ºæ—§çš„Apiæ¥å®ç°;</p>
</blockquote>

<h6 id="æ—§api">æ—§Api</h6>

<p>1.å¼•å…¥å¤´æ–‡ä»¶</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;CoreTelephony/CTCallCenter.h&gt;
#import &lt;CoreTelephony/CTCall.h&gt;
</code></pre></div></div>

<p>2.å£°æ˜å˜é‡</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
@property (nonatomic,strong)CTCallCenter    *callCenter;
#pragma clang diagnostic pop
</code></pre></div></div>

<p>3.ç›‘å¬ã€ä¸€èˆ¬åœ¨viewDidLoadä¸­è°ƒç”¨ã€‘</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#pragma mark - ç”µè¯ç›‘å¬
-(void)addCallMonitor {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
    // ç”µè¯ç›‘å¬
    ybWeakSelf;
    self.callCenter = [CTCallCenter new];
    self.callCenter.callEventHandler = ^(CTCall *call) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if ([call.callState isEqualToString:CTCallStateDialing]) {
                NSLog(@"call-ç”µè¯ä¸»åŠ¨æ‹¨æ‰“ç”µè¯");
            } else if ([call.callState isEqualToString:CTCallStateConnected]) {
                NSLog(@"call-ç”µè¯æ¥é€š");
                [weakSelf callConnectDeal];
            } else if ([call.callState isEqualToString:CTCallStateDisconnected]) {
                NSLog(@"call-ç”µè¯æŒ‚æ–­");
            } else if ([call.callState isEqualToString:CTCallStateIncoming]) {
                NSLog(@"call-ç”µè¯è¢«å«");
            } else {
                NSLog(@"call-ç”µè¯å…¶ä»–çŠ¶æ€");
            }
        });
    };
#pragma clang diagnostic pop
}

// è¯­éŸ³çš„å¤„ç†
-(void)callConnectDeal {
    ImCallType imCalltype = (_avCallType == AVCallType_Video ? ImCallType_Video:ImCallType_Audio);
    if (_callStatus == AVCallStatus_Waitting) {
        if (_avcUiType == AVCallUiType_Recevier) {
            [[YBImManager shareInstance] imAVCallRefuseType:imCalltype andInfo:_userInfo];
        }else{
            [[YBImManager shareInstance] imAVCallRequestCancelType:imCalltype andInfo:_userInfo];
        }
        [[NSUserDefaults standardUserDefaults] setBool:NO forKey:ybIsStartCallKey];
        [[YBAVCallManager shareInstance] cancelAVCallReq:YES];
    }else if(_callStatus == AVCallStatus_Connect){
        [[YBImManager shareInstance] imAVCallTimeType:imCalltype andInfo:_userInfo andTime:[YBTools getHMSWithSS:_connectView.currentLiveTime]];
        [self appKilled];
    }
}
-(void)removeCallMonitor {
    
}
</code></pre></div></div>

<h6 id="callkitå¤„ç†æ–¹å¼">CallKitå¤„ç†æ–¹å¼</h6>

<p>1.å¼•å…¥å¤´æ–‡ä»¶</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;CallKit/CXCallObserver.h&gt;
#import &lt;CallKit/CXCall.h&gt;
</code></pre></div></div>

<p>2.è®¾ç½®ä»£ç†</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CXCallObserverDelegate
</code></pre></div></div>

<p>3.å£°æ˜å˜é‡</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property (nonatomic, strong) CXCallObserver *callObserver;
</code></pre></div></div>

<p>4.ç›‘å¬ã€ä¸€èˆ¬åœ¨viewDidLoadä¸­è°ƒç”¨ã€‘</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#pragma mark - ç”µè¯ç›‘å¬
-(void)addCallMonitor {
    // ç”µè¯ç›‘å¬
    if (!self.callObserver) {
        self.callObserver = [[CXCallObserver alloc] init];
        [self.callObserver setDelegate:self queue:dispatch_get_main_queue()];
    }
}
#pragma mark - ç”µè¯çš„ç›‘å¬
- (void)callObserver:(CXCallObserver *)callObserver callChanged:(CXCall *)call {
    if ((call.outgoing &amp;&amp; call.hasConnected) ||
        call.hasConnected) {
        // è¯´æ˜ä¸»åŠ¨æ‹¨æ‰“ æˆ–è€… æ¥é€šäº†ç”µè¯
        dispatch_async(dispatch_get_main_queue(), ^{
            if (_callStatus == AudioCallStatus_Waitting) {
                if (_acUiType == AudioCallUiType_Recevier) {
                    [[YBImManager shareInstance] imAudioCallRefuse:_userInfo];
                }else{
                    [[YBImManager shareInstance] imAudioCallRequestCancel:_userInfo];
                }
                [[NSUserDefaults standardUserDefaults] setBool:NO forKey:ybIsStartCallKey];
                [[YBAudioManager shareInstance] cancelAudioCallReq:YES];
            }else if(_callStatus == AudioCallStatus_Connect){
                [[YBImManager shareInstance] imAudioCallTime:_userInfo andTime:[YBTools getHMSWithSS:_connectView.currentLiveTime]];
                [self callEnd];
            }
        });
    }
    if ((call.hasConnected &amp;&amp; call.hasEnded) ||
        (call.outgoing &amp;&amp; call.hasEnded)) {
        // è¯´æ˜æ˜¯æ¥é€šè¿‡ç”µè¯å¹¶å·²æŒ‚æ–­ æˆ–è€… æ‹¨æ‰“å¹¶å·²æŒ‚æ–­
        dispatch_async(dispatch_get_main_queue(), ^{
           
        });
        return;
    }
}
-(void)removeCallMonitor {
    if (self.callObserver) {
        [self.callObserver setDelegate:nil queue:dispatch_get_main_queue()];
        self.callObserver = nil;
    }
}
</code></pre></div></div>

:ET